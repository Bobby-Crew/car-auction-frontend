{"ast":null,"code":"'use client';\n\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { DEFAULT_STEP } from '../utils/constants.js';\nimport { getViewportRect } from '../utils/getViewportRect.js';\nimport { subscribeToVisualViewportResize } from '../utils/subscribeToVisualViewportResize.js';\nimport { ownerDocument, ownerWindow } from '../../utils/owner.js';\nimport { useLatestRef } from '../../utils/useLatestRef.js';\nimport { isWebKit } from '../../utils/detectBrowser.js';\nimport { mergeReactProps } from '../../utils/mergeReactProps.js';\nimport { NumberFieldRootDataAttributes } from './NumberFieldRootDataAttributes.js';\n\n/**\n * @ignore - internal hook.\n */\nexport function useScrub(params) {\n  const {\n    disabled,\n    readOnly,\n    value,\n    inputRef,\n    incrementValue,\n    getStepAmount\n  } = params;\n  const latestValueRef = useLatestRef(value);\n  const scrubHandleRef = React.useRef(null);\n  const scrubAreaRef = React.useRef(null);\n  const avoidFlickerTimeoutRef = React.useRef(-1);\n  const isScrubbingRef = React.useRef(false);\n  const scrubAreaCursorRef = React.useRef(null);\n  const virtualCursorCoords = React.useRef({\n    x: 0,\n    y: 0\n  });\n  const visualScaleRef = React.useRef(1);\n  const [isScrubbing, setIsScrubbing] = React.useState(false);\n  const [cursorTransform, setCursorTransform] = React.useState('');\n  React.useEffect(() => {\n    return () => {\n      clearTimeout(avoidFlickerTimeoutRef.current);\n    };\n  }, []);\n  React.useEffect(() => {\n    if (!isScrubbing || !scrubAreaCursorRef.current) {\n      return undefined;\n    }\n    return subscribeToVisualViewportResize(scrubAreaCursorRef.current, visualScaleRef);\n  }, [isScrubbing]);\n  const onScrub = React.useCallback(({\n    movementX,\n    movementY\n  }) => {\n    const virtualCursor = scrubAreaCursorRef.current;\n    const scrubAreaEl = scrubAreaRef.current;\n    const scrubHandle = scrubHandleRef.current;\n    if (!virtualCursor || !scrubAreaEl || !scrubHandle) {\n      return;\n    }\n    const rect = getViewportRect(scrubHandle.teleportDistance, scrubAreaEl);\n    const coords = virtualCursorCoords.current;\n    const newCoords = {\n      x: Math.round(coords.x + movementX),\n      y: Math.round(coords.y + movementY)\n    };\n    const cursorWidth = virtualCursor.offsetWidth;\n    const cursorHeight = virtualCursor.offsetHeight;\n    if (newCoords.x + cursorWidth / 2 < rect.x) {\n      newCoords.x = rect.width - cursorWidth / 2;\n    } else if (newCoords.x + cursorWidth / 2 > rect.width) {\n      newCoords.x = rect.x - cursorWidth / 2;\n    }\n    if (newCoords.y + cursorHeight / 2 < rect.y) {\n      newCoords.y = rect.height - cursorHeight / 2;\n    } else if (newCoords.y + cursorHeight / 2 > rect.height) {\n      newCoords.y = rect.y - cursorHeight / 2;\n    }\n    virtualCursorCoords.current = newCoords;\n    setCursorTransform(`translate3d(${newCoords.x}px,${newCoords.y}px,0) scale(${1 / visualScaleRef.current})`);\n  }, []);\n  const onScrubbingChange = React.useCallback((scrubbingValue, {\n    clientX,\n    clientY\n  }) => {\n    ReactDOM.flushSync(() => {\n      setIsScrubbing(scrubbingValue);\n    });\n    const virtualCursor = scrubAreaCursorRef.current;\n    if (!virtualCursor || !scrubbingValue) {\n      return;\n    }\n    const initialCoords = {\n      x: clientX - virtualCursor.offsetWidth / 2,\n      y: clientY - virtualCursor.offsetHeight / 2\n    };\n    virtualCursorCoords.current = initialCoords;\n    setCursorTransform(`translate3d(${initialCoords.x}px,${initialCoords.y}px,0) scale(${1 / visualScaleRef.current})`);\n  }, []);\n  const getScrubAreaProps = React.useCallback((externalProps = {}) => mergeReactProps(externalProps, {\n    role: 'presentation',\n    [NumberFieldRootDataAttributes.scrubbing]: isScrubbing || undefined,\n    style: {\n      touchAction: 'none',\n      WebkitUserSelect: 'none',\n      userSelect: 'none'\n    },\n    onPointerDown(event) {\n      const isMainButton = !event.button || event.button === 0;\n      if (event.defaultPrevented || readOnly || !isMainButton || disabled) {\n        return;\n      }\n      if (event.pointerType === 'mouse') {\n        event.preventDefault();\n        inputRef.current?.focus();\n      }\n      isScrubbingRef.current = true;\n      onScrubbingChange(true, event.nativeEvent);\n\n      // WebKit causes significant layout shift with the native message, so we can't use it.\n      if (!isWebKit()) {\n        // There can be some frames where there's no cursor at all when requesting the pointer lock.\n        // This is a workaround to avoid flickering.\n        avoidFlickerTimeoutRef.current = window.setTimeout(async () => {\n          try {\n            // Avoid non-deterministic errors in testing environments. This error sometimes\n            // appears:\n            // \"The root document of this element is not valid for pointer lock.\"\n            // We need to await it even though it doesn't appear to return a promise in the\n            // types in order for the `catch` to work.\n            await ownerDocument(scrubAreaRef.current).body.requestPointerLock();\n          } catch {\n            //\n          }\n        }, 20);\n      }\n    }\n  }), [readOnly, disabled, onScrubbingChange, inputRef, isScrubbing]);\n  const getScrubAreaCursorProps = React.useCallback((externalProps = {}) => mergeReactProps({\n    ...externalProps,\n    style: {\n      ...externalProps.style,\n      transform: `${cursorTransform} ${externalProps.style?.transform || ''}`.trim()\n    }\n  }, {\n    role: 'presentation',\n    style: {\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      pointerEvents: 'none'\n    }\n  }), [cursorTransform]);\n  React.useEffect(function registerGlobalScrubbingEventListeners() {\n    if (!inputRef.current || disabled || readOnly) {\n      return undefined;\n    }\n    let cumulativeDelta = 0;\n    function handleScrubPointerUp(event) {\n      clearTimeout(avoidFlickerTimeoutRef.current);\n      isScrubbingRef.current = false;\n      onScrubbingChange(false, event);\n      if (!isWebKit()) {\n        try {\n          // Avoid errors in testing environments.\n          ownerDocument(scrubAreaRef.current).exitPointerLock();\n        } catch {\n          //\n        }\n      }\n    }\n    function handleScrubPointerMove(event) {\n      if (!isScrubbingRef.current || !scrubHandleRef.current) {\n        return;\n      }\n\n      // Prevent text selection.\n      event.preventDefault();\n      onScrub(event);\n      const {\n        direction,\n        pixelSensitivity\n      } = scrubHandleRef.current;\n      const {\n        movementX,\n        movementY\n      } = event;\n      cumulativeDelta += direction === 'vertical' ? movementY : movementX;\n      if (Math.abs(cumulativeDelta) >= pixelSensitivity) {\n        cumulativeDelta = 0;\n        const dValue = direction === 'vertical' ? -movementY : movementX;\n        incrementValue(dValue * (getStepAmount() ?? DEFAULT_STEP), 1);\n      }\n    }\n    const win = ownerWindow(inputRef.current);\n    win.addEventListener('pointerup', handleScrubPointerUp, true);\n    win.addEventListener('pointermove', handleScrubPointerMove, true);\n    return () => {\n      win.removeEventListener('pointerup', handleScrubPointerUp, true);\n      win.removeEventListener('pointermove', handleScrubPointerMove, true);\n    };\n  }, [disabled, readOnly, incrementValue, latestValueRef, getStepAmount, inputRef, onScrubbingChange, onScrub]);\n\n  // Prevent scrolling using touch input when scrubbing.\n  React.useEffect(function registerScrubberTouchPreventListener() {\n    const element = scrubAreaRef.current;\n    if (!element || disabled || readOnly) {\n      return undefined;\n    }\n    function handleTouchStart(event) {\n      if (event.touches.length === 1) {\n        event.preventDefault();\n      }\n    }\n    element.addEventListener('touchstart', handleTouchStart);\n    return () => {\n      element.removeEventListener('touchstart', handleTouchStart);\n    };\n  }, [disabled, readOnly]);\n  return React.useMemo(() => ({\n    isScrubbing,\n    getScrubAreaProps,\n    getScrubAreaCursorProps,\n    scrubAreaCursorRef,\n    scrubAreaRef,\n    scrubHandleRef\n  }), [isScrubbing, getScrubAreaProps, getScrubAreaCursorProps]);\n}","map":{"version":3,"names":["React","ReactDOM","DEFAULT_STEP","getViewportRect","subscribeToVisualViewportResize","ownerDocument","ownerWindow","useLatestRef","isWebKit","mergeReactProps","NumberFieldRootDataAttributes","useScrub","params","disabled","readOnly","value","inputRef","incrementValue","getStepAmount","latestValueRef","scrubHandleRef","useRef","scrubAreaRef","avoidFlickerTimeoutRef","isScrubbingRef","scrubAreaCursorRef","virtualCursorCoords","x","y","visualScaleRef","isScrubbing","setIsScrubbing","useState","cursorTransform","setCursorTransform","useEffect","clearTimeout","current","undefined","onScrub","useCallback","movementX","movementY","virtualCursor","scrubAreaEl","scrubHandle","rect","teleportDistance","coords","newCoords","Math","round","cursorWidth","offsetWidth","cursorHeight","offsetHeight","width","height","onScrubbingChange","scrubbingValue","clientX","clientY","flushSync","initialCoords","getScrubAreaProps","externalProps","role","scrubbing","style","touchAction","WebkitUserSelect","userSelect","onPointerDown","event","isMainButton","button","defaultPrevented","pointerType","preventDefault","focus","nativeEvent","window","setTimeout","body","requestPointerLock","getScrubAreaCursorProps","transform","trim","position","top","left","pointerEvents","registerGlobalScrubbingEventListeners","cumulativeDelta","handleScrubPointerUp","exitPointerLock","handleScrubPointerMove","direction","pixelSensitivity","abs","dValue","win","addEventListener","removeEventListener","registerScrubberTouchPreventListener","element","handleTouchStart","touches","length","useMemo"],"sources":["/Users/bobbycrew/Documents/Uni/Second Year/Car-Auction-Site-Y2--main/Frontend/node_modules/@base-ui-components/react/esm/number-field/root/useScrub.js"],"sourcesContent":["'use client';\n\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { DEFAULT_STEP } from '../utils/constants.js';\nimport { getViewportRect } from '../utils/getViewportRect.js';\nimport { subscribeToVisualViewportResize } from '../utils/subscribeToVisualViewportResize.js';\nimport { ownerDocument, ownerWindow } from '../../utils/owner.js';\nimport { useLatestRef } from '../../utils/useLatestRef.js';\nimport { isWebKit } from '../../utils/detectBrowser.js';\nimport { mergeReactProps } from '../../utils/mergeReactProps.js';\nimport { NumberFieldRootDataAttributes } from './NumberFieldRootDataAttributes.js';\n\n/**\n * @ignore - internal hook.\n */\nexport function useScrub(params) {\n  const {\n    disabled,\n    readOnly,\n    value,\n    inputRef,\n    incrementValue,\n    getStepAmount\n  } = params;\n  const latestValueRef = useLatestRef(value);\n  const scrubHandleRef = React.useRef(null);\n  const scrubAreaRef = React.useRef(null);\n  const avoidFlickerTimeoutRef = React.useRef(-1);\n  const isScrubbingRef = React.useRef(false);\n  const scrubAreaCursorRef = React.useRef(null);\n  const virtualCursorCoords = React.useRef({\n    x: 0,\n    y: 0\n  });\n  const visualScaleRef = React.useRef(1);\n  const [isScrubbing, setIsScrubbing] = React.useState(false);\n  const [cursorTransform, setCursorTransform] = React.useState('');\n  React.useEffect(() => {\n    return () => {\n      clearTimeout(avoidFlickerTimeoutRef.current);\n    };\n  }, []);\n  React.useEffect(() => {\n    if (!isScrubbing || !scrubAreaCursorRef.current) {\n      return undefined;\n    }\n    return subscribeToVisualViewportResize(scrubAreaCursorRef.current, visualScaleRef);\n  }, [isScrubbing]);\n  const onScrub = React.useCallback(({\n    movementX,\n    movementY\n  }) => {\n    const virtualCursor = scrubAreaCursorRef.current;\n    const scrubAreaEl = scrubAreaRef.current;\n    const scrubHandle = scrubHandleRef.current;\n    if (!virtualCursor || !scrubAreaEl || !scrubHandle) {\n      return;\n    }\n    const rect = getViewportRect(scrubHandle.teleportDistance, scrubAreaEl);\n    const coords = virtualCursorCoords.current;\n    const newCoords = {\n      x: Math.round(coords.x + movementX),\n      y: Math.round(coords.y + movementY)\n    };\n    const cursorWidth = virtualCursor.offsetWidth;\n    const cursorHeight = virtualCursor.offsetHeight;\n    if (newCoords.x + cursorWidth / 2 < rect.x) {\n      newCoords.x = rect.width - cursorWidth / 2;\n    } else if (newCoords.x + cursorWidth / 2 > rect.width) {\n      newCoords.x = rect.x - cursorWidth / 2;\n    }\n    if (newCoords.y + cursorHeight / 2 < rect.y) {\n      newCoords.y = rect.height - cursorHeight / 2;\n    } else if (newCoords.y + cursorHeight / 2 > rect.height) {\n      newCoords.y = rect.y - cursorHeight / 2;\n    }\n    virtualCursorCoords.current = newCoords;\n    setCursorTransform(`translate3d(${newCoords.x}px,${newCoords.y}px,0) scale(${1 / visualScaleRef.current})`);\n  }, []);\n  const onScrubbingChange = React.useCallback((scrubbingValue, {\n    clientX,\n    clientY\n  }) => {\n    ReactDOM.flushSync(() => {\n      setIsScrubbing(scrubbingValue);\n    });\n    const virtualCursor = scrubAreaCursorRef.current;\n    if (!virtualCursor || !scrubbingValue) {\n      return;\n    }\n    const initialCoords = {\n      x: clientX - virtualCursor.offsetWidth / 2,\n      y: clientY - virtualCursor.offsetHeight / 2\n    };\n    virtualCursorCoords.current = initialCoords;\n    setCursorTransform(`translate3d(${initialCoords.x}px,${initialCoords.y}px,0) scale(${1 / visualScaleRef.current})`);\n  }, []);\n  const getScrubAreaProps = React.useCallback((externalProps = {}) => mergeReactProps(externalProps, {\n    role: 'presentation',\n    [NumberFieldRootDataAttributes.scrubbing]: isScrubbing || undefined,\n    style: {\n      touchAction: 'none',\n      WebkitUserSelect: 'none',\n      userSelect: 'none'\n    },\n    onPointerDown(event) {\n      const isMainButton = !event.button || event.button === 0;\n      if (event.defaultPrevented || readOnly || !isMainButton || disabled) {\n        return;\n      }\n      if (event.pointerType === 'mouse') {\n        event.preventDefault();\n        inputRef.current?.focus();\n      }\n      isScrubbingRef.current = true;\n      onScrubbingChange(true, event.nativeEvent);\n\n      // WebKit causes significant layout shift with the native message, so we can't use it.\n      if (!isWebKit()) {\n        // There can be some frames where there's no cursor at all when requesting the pointer lock.\n        // This is a workaround to avoid flickering.\n        avoidFlickerTimeoutRef.current = window.setTimeout(async () => {\n          try {\n            // Avoid non-deterministic errors in testing environments. This error sometimes\n            // appears:\n            // \"The root document of this element is not valid for pointer lock.\"\n            // We need to await it even though it doesn't appear to return a promise in the\n            // types in order for the `catch` to work.\n            await ownerDocument(scrubAreaRef.current).body.requestPointerLock();\n          } catch {\n            //\n          }\n        }, 20);\n      }\n    }\n  }), [readOnly, disabled, onScrubbingChange, inputRef, isScrubbing]);\n  const getScrubAreaCursorProps = React.useCallback((externalProps = {}) => mergeReactProps({\n    ...externalProps,\n    style: {\n      ...externalProps.style,\n      transform: `${cursorTransform} ${externalProps.style?.transform || ''}`.trim()\n    }\n  }, {\n    role: 'presentation',\n    style: {\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      pointerEvents: 'none'\n    }\n  }), [cursorTransform]);\n  React.useEffect(function registerGlobalScrubbingEventListeners() {\n    if (!inputRef.current || disabled || readOnly) {\n      return undefined;\n    }\n    let cumulativeDelta = 0;\n    function handleScrubPointerUp(event) {\n      clearTimeout(avoidFlickerTimeoutRef.current);\n      isScrubbingRef.current = false;\n      onScrubbingChange(false, event);\n      if (!isWebKit()) {\n        try {\n          // Avoid errors in testing environments.\n          ownerDocument(scrubAreaRef.current).exitPointerLock();\n        } catch {\n          //\n        }\n      }\n    }\n    function handleScrubPointerMove(event) {\n      if (!isScrubbingRef.current || !scrubHandleRef.current) {\n        return;\n      }\n\n      // Prevent text selection.\n      event.preventDefault();\n      onScrub(event);\n      const {\n        direction,\n        pixelSensitivity\n      } = scrubHandleRef.current;\n      const {\n        movementX,\n        movementY\n      } = event;\n      cumulativeDelta += direction === 'vertical' ? movementY : movementX;\n      if (Math.abs(cumulativeDelta) >= pixelSensitivity) {\n        cumulativeDelta = 0;\n        const dValue = direction === 'vertical' ? -movementY : movementX;\n        incrementValue(dValue * (getStepAmount() ?? DEFAULT_STEP), 1);\n      }\n    }\n    const win = ownerWindow(inputRef.current);\n    win.addEventListener('pointerup', handleScrubPointerUp, true);\n    win.addEventListener('pointermove', handleScrubPointerMove, true);\n    return () => {\n      win.removeEventListener('pointerup', handleScrubPointerUp, true);\n      win.removeEventListener('pointermove', handleScrubPointerMove, true);\n    };\n  }, [disabled, readOnly, incrementValue, latestValueRef, getStepAmount, inputRef, onScrubbingChange, onScrub]);\n\n  // Prevent scrolling using touch input when scrubbing.\n  React.useEffect(function registerScrubberTouchPreventListener() {\n    const element = scrubAreaRef.current;\n    if (!element || disabled || readOnly) {\n      return undefined;\n    }\n    function handleTouchStart(event) {\n      if (event.touches.length === 1) {\n        event.preventDefault();\n      }\n    }\n    element.addEventListener('touchstart', handleTouchStart);\n    return () => {\n      element.removeEventListener('touchstart', handleTouchStart);\n    };\n  }, [disabled, readOnly]);\n  return React.useMemo(() => ({\n    isScrubbing,\n    getScrubAreaProps,\n    getScrubAreaCursorProps,\n    scrubAreaCursorRef,\n    scrubAreaRef,\n    scrubHandleRef\n  }), [isScrubbing, getScrubAreaProps, getScrubAreaCursorProps]);\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}