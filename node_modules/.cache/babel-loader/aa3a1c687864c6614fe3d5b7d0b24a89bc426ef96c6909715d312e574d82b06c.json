{"ast":null,"code":"'use client';\n\nimport * as React from 'react';\nimport { useScrub } from './useScrub.js';\nimport { formatNumber } from '../../utils/formatNumber.js';\nimport { toValidatedNumber } from '../utils/validate.js';\nimport { ARABIC_RE, HAN_RE, PERCENTAGES, getNumberLocaleDetails, parseNumber } from '../utils/parse.js';\nimport { CHANGE_VALUE_TICK_DELAY, DEFAULT_STEP, MAX_POINTER_MOVES_AFTER_TOUCH, SCROLLING_POINTER_MOVE_DISTANCE, START_AUTO_CHANGE_DELAY, TOUCH_TIMEOUT } from '../utils/constants.js';\nimport { isIOS } from '../../utils/detectBrowser.js';\nimport { mergeReactProps } from '../../utils/mergeReactProps.js';\nimport { ownerDocument, ownerWindow } from '../../utils/owner.js';\nimport { useControlled } from '../../utils/useControlled.js';\nimport { useEnhancedEffect } from '../../utils/useEnhancedEffect.js';\nimport { useEventCallback } from '../../utils/useEventCallback.js';\nimport { useForcedRerendering } from '../../utils/useForcedRerendering.js';\nimport { useBaseUiId } from '../../utils/useBaseUiId.js';\nimport { useLatestRef } from '../../utils/useLatestRef.js';\nimport { useFieldRootContext } from '../../field/root/FieldRootContext.js';\nimport { useFieldControlValidation } from '../../field/control/useFieldControlValidation.js';\nimport { useForkRef } from '../../utils/useForkRef.js';\nimport { useField } from '../../field/useField.js';\nexport function useNumberFieldRoot(params) {\n  const {\n    id: idProp,\n    name,\n    min,\n    max,\n    smallStep = 0.1,\n    step,\n    largeStep = 10,\n    required = false,\n    disabled: disabledProp = false,\n    invalid = false,\n    readOnly = false,\n    autoFocus = false,\n    allowWheelScrub = false,\n    format,\n    value: externalValue,\n    onValueChange: onValueChangeProp,\n    defaultValue\n  } = params;\n  const {\n    labelId,\n    setControlId,\n    validationMode,\n    setTouched,\n    setDirty,\n    validityData,\n    setValidityData,\n    disabled: fieldDisabled,\n    setFocused,\n    setFilled\n  } = useFieldRootContext();\n  const {\n    getInputValidationProps,\n    getValidationProps,\n    inputRef: inputValidationRef,\n    commitValidation\n  } = useFieldControlValidation();\n  const disabled = fieldDisabled || disabledProp;\n  const minWithDefault = min ?? Number.MIN_SAFE_INTEGER;\n  const maxWithDefault = max ?? Number.MAX_SAFE_INTEGER;\n  const minWithZeroDefault = min ?? 0;\n  const formatStyle = format?.style;\n  const inputRef = React.useRef(null);\n  const mergedRef = useForkRef(inputRef, inputValidationRef);\n  const id = useBaseUiId(idProp);\n  useEnhancedEffect(() => {\n    setControlId(id);\n    return () => {\n      setControlId(undefined);\n    };\n  }, [id, setControlId]);\n  const [valueUnwrapped, setValueUnwrapped] = useControlled({\n    controlled: externalValue,\n    default: defaultValue,\n    name: 'NumberField',\n    state: 'value'\n  });\n  const value = valueUnwrapped ?? null;\n  const valueRef = useLatestRef(value);\n  useEnhancedEffect(() => {\n    setFilled(value !== null);\n  }, [setFilled, value]);\n  useField({\n    id,\n    commitValidation,\n    value,\n    controlRef: inputRef\n  });\n  const forceRender = useForcedRerendering();\n  const formatOptionsRef = useLatestRef(format);\n  const onValueChange = useEventCallback(onValueChangeProp);\n  const startTickTimeoutRef = React.useRef(-1);\n  const tickIntervalRef = React.useRef(-1);\n  const intentionalTouchCheckTimeoutRef = React.useRef(-1);\n  const isPressedRef = React.useRef(false);\n  const isHoldingShiftRef = React.useRef(false);\n  const isHoldingAltRef = React.useRef(false);\n  const incrementDownCoordsRef = React.useRef({\n    x: 0,\n    y: 0\n  });\n  const movesAfterTouchRef = React.useRef(0);\n  const allowInputSyncRef = React.useRef(true);\n  const unsubscribeFromGlobalContextMenuRef = React.useRef(() => {});\n  const isTouchingButtonRef = React.useRef(false);\n  const hasTouchedInputRef = React.useRef(false);\n  const ignoreClickRef = React.useRef(false);\n  const pointerTypeRef = React.useRef('');\n  useEnhancedEffect(() => {\n    if (validityData.initialValue === null && value !== validityData.initialValue) {\n      setValidityData(prev => ({\n        ...prev,\n        initialValue: value\n      }));\n    }\n  }, [setValidityData, validityData.initialValue, value]);\n\n  // During SSR, the value is formatted on the server, whose locale may differ from the client's\n  // locale. This causes a hydration mismatch, which we manually suppress. This is preferable to\n  // rendering an empty input field and then updating it with the formatted value, as the user\n  // can still see the value prior to hydration, even if it's not formatted correctly.\n  const [inputValue, setInputValue] = React.useState(() => formatNumber(value, [], format));\n  const [inputMode, setInputMode] = React.useState('numeric');\n  const isMin = value != null && value <= minWithDefault;\n  const isMax = value != null && value >= maxWithDefault;\n  const getAllowedNonNumericKeys = useEventCallback(() => {\n    const {\n      decimal,\n      group,\n      currency\n    } = getNumberLocaleDetails([], format);\n    const keys = Array.from(new Set(['.', ',', decimal, group]));\n    if (formatStyle === 'percent') {\n      keys.push(...PERCENTAGES);\n    }\n    if (formatStyle === 'currency' && currency) {\n      keys.push(currency);\n    }\n    if (minWithDefault < 0) {\n      keys.push('-');\n    }\n    return keys;\n  });\n  const getStepAmount = useEventCallback(() => {\n    if (isHoldingAltRef.current) {\n      return smallStep;\n    }\n    if (isHoldingShiftRef.current) {\n      return largeStep;\n    }\n    return step;\n  });\n  const setValue = useEventCallback((unvalidatedValue, event) => {\n    const validatedValue = toValidatedNumber(unvalidatedValue, {\n      step: getStepAmount(),\n      format: formatOptionsRef.current,\n      minWithDefault,\n      maxWithDefault,\n      minWithZeroDefault\n    });\n    onValueChange?.(validatedValue, event);\n    setValueUnwrapped(validatedValue);\n    setDirty(validatedValue !== validityData.initialValue);\n    if (validationMode === 'onChange') {\n      commitValidation(validatedValue);\n    }\n\n    // We need to force a re-render, because while the value may be unchanged, the formatting may\n    // be different. This forces the `useEnhancedEffect` to run which acts as a single source of\n    // truth to sync the input value.\n    forceRender();\n  });\n  const incrementValue = useEventCallback((amount, dir, currentValue, event) => {\n    const prevValue = currentValue == null ? valueRef.current : currentValue;\n    const nextValue = typeof prevValue === 'number' ? prevValue + amount * dir : Math.max(0, min ?? 0);\n    setValue(nextValue, event);\n  });\n  const stopAutoChange = useEventCallback(() => {\n    window.clearTimeout(intentionalTouchCheckTimeoutRef.current);\n    window.clearTimeout(startTickTimeoutRef.current);\n    window.clearInterval(tickIntervalRef.current);\n    unsubscribeFromGlobalContextMenuRef.current();\n    movesAfterTouchRef.current = 0;\n  });\n  const startAutoChange = useEventCallback(isIncrement => {\n    stopAutoChange();\n    if (!inputRef.current) {\n      return;\n    }\n    const win = ownerWindow(inputRef.current);\n    function handleContextMenu(event) {\n      event.preventDefault();\n    }\n\n    // A global context menu is necessary to prevent the context menu from appearing when the touch\n    // is slightly outside of the element's hit area.\n    win.addEventListener('contextmenu', handleContextMenu);\n    unsubscribeFromGlobalContextMenuRef.current = () => {\n      win.removeEventListener('contextmenu', handleContextMenu);\n    };\n    win.addEventListener('pointerup', () => {\n      isPressedRef.current = false;\n      stopAutoChange();\n    }, {\n      once: true\n    });\n    function tick() {\n      const amount = getStepAmount() ?? DEFAULT_STEP;\n      incrementValue(amount, isIncrement ? 1 : -1);\n    }\n    tick();\n    startTickTimeoutRef.current = window.setTimeout(() => {\n      tickIntervalRef.current = window.setInterval(tick, CHANGE_VALUE_TICK_DELAY);\n    }, START_AUTO_CHANGE_DELAY);\n  });\n\n  // We need to update the input value when the external `value` prop changes. This ends up acting\n  // as a single source of truth to update the input value, bypassing the need to manually set it in\n  // each event handler internally in this hook.\n  // This is done inside a layout effect as an alternative to the technique to set state during\n  // render as we're accessing a ref, which must be inside an effect.\n  // https://react.dev/learn/you-might-not-need-an-effect#adjusting-some-state-when-a-prop-changes\n  //\n  // ESLint is disabled because it needs to run even if the parsed value hasn't changed, since the\n  // value still can be formatted differently.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useEnhancedEffect(function syncFormattedInputValueOnValueChange() {\n    // This ensures the value is only updated on blur rather than every keystroke, but still\n    // allows the input value to be updated when the value is changed externally.\n    if (!allowInputSyncRef.current) {\n      return;\n    }\n    const nextInputValue = formatNumber(value, [], formatOptionsRef.current);\n    if (nextInputValue !== inputValue) {\n      setInputValue(nextInputValue);\n    }\n  });\n  useEnhancedEffect(function setDynamicInputModeForIOS() {\n    if (!isIOS()) {\n      return;\n    }\n\n    // iOS numeric software keyboard doesn't have a minus key, so we need to use the default\n    // keyboard to let the user input a negative number.\n    let computedInputMode = 'text';\n    if (minWithDefault >= 0) {\n      // iOS numeric software keyboard doesn't have a decimal key for \"numeric\" input mode, but\n      // this is better than the \"text\" input if possible to use.\n      computedInputMode = 'decimal';\n    }\n    setInputMode(computedInputMode);\n  }, [minWithDefault, formatStyle]);\n  React.useEffect(() => {\n    return () => stopAutoChange();\n  }, [stopAutoChange]);\n  React.useEffect(function registerGlobalStepModifierKeyListeners() {\n    if (disabled || readOnly || !inputRef.current) {\n      return undefined;\n    }\n    function handleWindowKeyDown(event) {\n      if (event.shiftKey) {\n        isHoldingShiftRef.current = true;\n      }\n      if (event.altKey) {\n        isHoldingAltRef.current = true;\n      }\n    }\n    function handleWindowKeyUp(event) {\n      if (!event.shiftKey) {\n        isHoldingShiftRef.current = false;\n      }\n      if (!event.altKey) {\n        isHoldingAltRef.current = false;\n      }\n    }\n    function handleWindowBlur() {\n      // A keyup event may not be dispatched when the window loses focus.\n      isHoldingShiftRef.current = false;\n      isHoldingAltRef.current = false;\n    }\n    const win = ownerWindow(inputRef.current);\n    win.addEventListener('keydown', handleWindowKeyDown, true);\n    win.addEventListener('keyup', handleWindowKeyUp, true);\n    win.addEventListener('blur', handleWindowBlur);\n    return () => {\n      win.removeEventListener('keydown', handleWindowKeyDown, true);\n      win.removeEventListener('keyup', handleWindowKeyUp, true);\n      win.removeEventListener('blur', handleWindowBlur);\n    };\n  }, [disabled, readOnly]);\n\n  // The `onWheel` prop can't be prevented, so we need to use a global event listener.\n  React.useEffect(function registerElementWheelListener() {\n    const element = inputRef.current;\n    if (disabled || readOnly || !allowWheelScrub || !element) {\n      return undefined;\n    }\n    function handleWheel(event) {\n      if (\n      // Allow pinch-zooming.\n      event.ctrlKey || ownerDocument(inputRef.current).activeElement !== inputRef.current) {\n        return;\n      }\n\n      // Prevent the default behavior to avoid scrolling the page.\n      event.preventDefault();\n      const amount = getStepAmount() ?? DEFAULT_STEP;\n      incrementValue(amount, event.deltaY > 0 ? -1 : 1, undefined, event);\n    }\n    element.addEventListener('wheel', handleWheel);\n    return () => {\n      element.removeEventListener('wheel', handleWheel);\n    };\n  }, [allowWheelScrub, incrementValue, disabled, readOnly, largeStep, step, getStepAmount]);\n  const getGroupProps = React.useCallback((externalProps = {}) => mergeReactProps(externalProps, {\n    role: 'group'\n  }), []);\n  const getCommonButtonProps = React.useCallback((isIncrement, externalProps = {}) => {\n    function commitValue(nativeEvent) {\n      allowInputSyncRef.current = true;\n\n      // The input may be dirty but not yet blurred, so the value won't have been committed.\n      const parsedValue = parseNumber(inputValue, formatOptionsRef.current);\n      if (parsedValue !== null) {\n        // The increment value function needs to know the current input value to increment it\n        // correctly.\n        valueRef.current = parsedValue;\n        setValue(parsedValue, nativeEvent);\n      }\n    }\n    return mergeReactProps(externalProps, {\n      disabled: disabled || (isIncrement ? isMax : isMin),\n      type: 'button',\n      'aria-readonly': readOnly || undefined,\n      'aria-label': isIncrement ? 'Increase' : 'Decrease',\n      'aria-controls': id,\n      // Keyboard users shouldn't have access to the buttons, since they can use the input element\n      // to change the value. On the other hand, `aria-hidden` is not applied because touch screen\n      // readers should be able to use the buttons.\n      tabIndex: -1,\n      style: {\n        WebkitUserSelect: 'none',\n        userSelect: 'none'\n      },\n      onTouchStart() {\n        isTouchingButtonRef.current = true;\n      },\n      onTouchEnd() {\n        isTouchingButtonRef.current = false;\n      },\n      onClick(event) {\n        const isDisabled = disabled || readOnly || (isIncrement ? isMax : isMin);\n        if (event.defaultPrevented || isDisabled || (\n        // If it's not a keyboard/virtual click, ignore.\n        pointerTypeRef.current === 'touch' ? ignoreClickRef.current : event.detail !== 0)) {\n          return;\n        }\n        commitValue(event.nativeEvent);\n        const amount = getStepAmount() ?? DEFAULT_STEP;\n        incrementValue(amount, isIncrement ? 1 : -1, undefined, event.nativeEvent);\n      },\n      onPointerDown(event) {\n        const isMainButton = !event.button || event.button === 0;\n        const isDisabled = disabled || (isIncrement ? isMax : isMin);\n        if (event.defaultPrevented || readOnly || !isMainButton || isDisabled) {\n          return;\n        }\n        pointerTypeRef.current = event.pointerType;\n        ignoreClickRef.current = false;\n        isPressedRef.current = true;\n        incrementDownCoordsRef.current = {\n          x: event.clientX,\n          y: event.clientY\n        };\n        commitValue(event.nativeEvent);\n\n        // Note: \"pen\" is sometimes returned for mouse usage on Linux Chrome.\n        if (event.pointerType !== 'touch') {\n          event.preventDefault();\n          inputRef.current?.focus();\n          startAutoChange(isIncrement);\n        } else {\n          // We need to check if the pointerdown was intentional, and not the result of a scroll\n          // or pinch-zoom. In that case, we don't want to change the value.\n          intentionalTouchCheckTimeoutRef.current = window.setTimeout(() => {\n            const moves = movesAfterTouchRef.current;\n            movesAfterTouchRef.current = 0;\n            if (moves < MAX_POINTER_MOVES_AFTER_TOUCH) {\n              ignoreClickRef.current = true;\n              startAutoChange(isIncrement);\n            } else {\n              stopAutoChange();\n            }\n          }, TOUCH_TIMEOUT);\n        }\n      },\n      onPointerMove(event) {\n        const isDisabled = disabled || readOnly || (isIncrement ? isMax : isMin);\n        if (isDisabled || event.pointerType !== 'touch' || !isPressedRef.current) {\n          return;\n        }\n        movesAfterTouchRef.current += 1;\n        const {\n          x,\n          y\n        } = incrementDownCoordsRef.current;\n        const dx = x - event.clientX;\n        const dy = y - event.clientY;\n\n        // An alternative to this technique is to detect when the NumberField's parent container\n        // has been scrolled\n        if (dx ** 2 + dy ** 2 > SCROLLING_POINTER_MOVE_DISTANCE ** 2) {\n          stopAutoChange();\n        }\n      },\n      onMouseEnter(event) {\n        const isDisabled = disabled || readOnly || (isIncrement ? isMax : isMin);\n        if (event.defaultPrevented || isDisabled || !isPressedRef.current || isTouchingButtonRef.current) {\n          return;\n        }\n        startAutoChange(isIncrement);\n      },\n      onMouseLeave() {\n        if (isTouchingButtonRef.current) {\n          return;\n        }\n        stopAutoChange();\n      },\n      onMouseUp() {\n        if (isTouchingButtonRef.current) {\n          return;\n        }\n        stopAutoChange();\n      }\n    });\n  }, [disabled, isMax, isMin, readOnly, id, getStepAmount, incrementValue, inputValue, formatOptionsRef, valueRef, setValue, startAutoChange, stopAutoChange]);\n  const getIncrementButtonProps = React.useCallback(externalProps => getCommonButtonProps(true, externalProps), [getCommonButtonProps]);\n  const getDecrementButtonProps = React.useCallback(externalProps => getCommonButtonProps(false, externalProps), [getCommonButtonProps]);\n  const getInputProps = React.useCallback((externalProps = {}) => mergeReactProps(getInputValidationProps(getValidationProps(externalProps)), {\n    id,\n    required,\n    autoFocus,\n    name,\n    disabled,\n    readOnly,\n    inputMode,\n    value: inputValue,\n    ref: mergedRef,\n    type: 'text',\n    autoComplete: 'off',\n    autoCorrect: 'off',\n    spellCheck: 'false',\n    'aria-roledescription': 'Number field',\n    'aria-invalid': invalid || undefined,\n    'aria-labelledby': labelId,\n    // If the server's locale does not match the client's locale, the formatting may not match,\n    // causing a hydration mismatch.\n    suppressHydrationWarning: true,\n    onFocus(event) {\n      if (event.defaultPrevented || readOnly || disabled || hasTouchedInputRef.current) {\n        return;\n      }\n      hasTouchedInputRef.current = true;\n      setFocused(true);\n\n      // Browsers set selection at the start of the input field by default. We want to set it at\n      // the end for the first focus.\n      const target = event.currentTarget;\n      const length = target.value.length;\n      target.setSelectionRange(length, length);\n    },\n    onBlur(event) {\n      if (event.defaultPrevented || readOnly || disabled) {\n        return;\n      }\n      setTouched(true);\n      setFocused(false);\n      if (validationMode === 'onBlur') {\n        commitValidation(valueRef.current);\n      }\n      allowInputSyncRef.current = true;\n      if (inputValue.trim() === '') {\n        setValue(null);\n        return;\n      }\n      const parsedValue = parseNumber(inputValue, formatOptionsRef.current);\n      if (parsedValue !== null) {\n        setValue(parsedValue, event.nativeEvent);\n      }\n    },\n    onChange(event) {\n      // Workaround for https://github.com/facebook/react/issues/9023\n      if (event.nativeEvent.defaultPrevented) {\n        return;\n      }\n      allowInputSyncRef.current = false;\n      const targetValue = event.target.value;\n      if (targetValue.trim() === '') {\n        setInputValue(targetValue);\n        setValue(null, event.nativeEvent);\n        return;\n      }\n      if (event.isTrusted) {\n        setInputValue(targetValue);\n        return;\n      }\n      const parsedValue = parseNumber(targetValue, formatOptionsRef.current);\n      if (parsedValue !== null) {\n        setInputValue(targetValue);\n        setValue(parsedValue, event.nativeEvent);\n      }\n    },\n    onKeyDown(event) {\n      if (event.defaultPrevented || readOnly || disabled) {\n        return;\n      }\n      const nativeEvent = event.nativeEvent;\n      allowInputSyncRef.current = true;\n      const allowedNonNumericKeys = getAllowedNonNumericKeys();\n      let isAllowedNonNumericKey = allowedNonNumericKeys.includes(event.key);\n      const {\n        decimal,\n        currency,\n        percentSign\n      } = getNumberLocaleDetails([], formatOptionsRef.current);\n      const selectionStart = event.currentTarget.selectionStart;\n      const selectionEnd = event.currentTarget.selectionEnd;\n      const isAllSelected = selectionStart === 0 && selectionEnd === inputValue.length;\n\n      // Allow the minus key only if there isn't already a plus or minus sign, or if all the text\n      // is selected, or if only the minus sign is highlighted.\n      if (event.key === '-' && allowedNonNumericKeys.includes('-')) {\n        const isMinusHighlighted = selectionStart === 0 && selectionEnd === 1 && inputValue[0] === '-';\n        isAllowedNonNumericKey = !inputValue.includes('-') || isAllSelected || isMinusHighlighted;\n      }\n\n      // Only allow one of each symbol.\n      [decimal, currency, percentSign].forEach(symbol => {\n        if (event.key === symbol) {\n          const symbolIndex = inputValue.indexOf(symbol);\n          const isSymbolHighlighted = selectionStart === symbolIndex && selectionEnd === symbolIndex + 1;\n          isAllowedNonNumericKey = !inputValue.includes(symbol) || isAllSelected || isSymbolHighlighted;\n        }\n      });\n      const isLatinNumeral = /^[0-9]$/.test(event.key);\n      const isArabicNumeral = ARABIC_RE.test(event.key);\n      const isHanNumeral = HAN_RE.test(event.key);\n      const isNavigateKey = ['Backspace', 'Delete', 'ArrowLeft', 'ArrowRight', 'Tab', 'Enter'].includes(event.key);\n      if (\n      // Allow composition events (e.g., pinyin)\n      // event.nativeEvent.isComposing does not work in Safari:\n      // https://bugs.webkit.org/show_bug.cgi?id=165004\n      event.which === 229 || event.altKey || event.ctrlKey || event.metaKey || isAllowedNonNumericKey || isLatinNumeral || isArabicNumeral || isHanNumeral || isNavigateKey) {\n        return;\n      }\n\n      // We need to commit the number at this point if the input hasn't been blurred.\n      const parsedValue = parseNumber(inputValue, formatOptionsRef.current);\n      const amount = getStepAmount() ?? DEFAULT_STEP;\n\n      // Prevent insertion of text or caret from moving.\n      event.preventDefault();\n      if (event.key === 'ArrowUp') {\n        incrementValue(amount, 1, parsedValue, nativeEvent);\n      } else if (event.key === 'ArrowDown') {\n        incrementValue(amount, -1, parsedValue, nativeEvent);\n      } else if (event.key === 'Home' && min != null) {\n        setValue(min, nativeEvent);\n      } else if (event.key === 'End' && max != null) {\n        setValue(max, nativeEvent);\n      }\n    },\n    onPaste(event) {\n      if (event.defaultPrevented || readOnly || disabled) {\n        return;\n      }\n\n      // Prevent `onChange` from being called.\n      event.preventDefault();\n      const clipboardData = event.clipboardData || window.Clipboard;\n      const pastedData = clipboardData.getData('text/plain');\n      const parsedValue = parseNumber(pastedData, formatOptionsRef.current);\n      if (parsedValue !== null) {\n        allowInputSyncRef.current = false;\n        setValue(parsedValue, event.nativeEvent);\n        setInputValue(pastedData);\n      }\n    }\n  }), [getInputValidationProps, getValidationProps, id, required, autoFocus, name, disabled, readOnly, inputMode, inputValue, mergedRef, invalid, labelId, setFocused, setTouched, validationMode, formatOptionsRef, commitValidation, valueRef, setValue, getAllowedNonNumericKeys, getStepAmount, min, max, incrementValue]);\n  const scrub = useScrub({\n    disabled,\n    readOnly,\n    value,\n    inputRef,\n    incrementValue,\n    getStepAmount\n  });\n  return React.useMemo(() => ({\n    getGroupProps,\n    getInputProps,\n    getIncrementButtonProps,\n    getDecrementButtonProps,\n    inputRef: mergedRef,\n    inputValue,\n    value,\n    ...scrub\n  }), [getGroupProps, getInputProps, getIncrementButtonProps, getDecrementButtonProps, mergedRef, inputValue, value, scrub]);\n}\nexport let UseNumberFieldRoot;","map":{"version":3,"names":["React","useScrub","formatNumber","toValidatedNumber","ARABIC_RE","HAN_RE","PERCENTAGES","getNumberLocaleDetails","parseNumber","CHANGE_VALUE_TICK_DELAY","DEFAULT_STEP","MAX_POINTER_MOVES_AFTER_TOUCH","SCROLLING_POINTER_MOVE_DISTANCE","START_AUTO_CHANGE_DELAY","TOUCH_TIMEOUT","isIOS","mergeReactProps","ownerDocument","ownerWindow","useControlled","useEnhancedEffect","useEventCallback","useForcedRerendering","useBaseUiId","useLatestRef","useFieldRootContext","useFieldControlValidation","useForkRef","useField","useNumberFieldRoot","params","id","idProp","name","min","max","smallStep","step","largeStep","required","disabled","disabledProp","invalid","readOnly","autoFocus","allowWheelScrub","format","value","externalValue","onValueChange","onValueChangeProp","defaultValue","labelId","setControlId","validationMode","setTouched","setDirty","validityData","setValidityData","fieldDisabled","setFocused","setFilled","getInputValidationProps","getValidationProps","inputRef","inputValidationRef","commitValidation","minWithDefault","Number","MIN_SAFE_INTEGER","maxWithDefault","MAX_SAFE_INTEGER","minWithZeroDefault","formatStyle","style","useRef","mergedRef","undefined","valueUnwrapped","setValueUnwrapped","controlled","default","state","valueRef","controlRef","forceRender","formatOptionsRef","startTickTimeoutRef","tickIntervalRef","intentionalTouchCheckTimeoutRef","isPressedRef","isHoldingShiftRef","isHoldingAltRef","incrementDownCoordsRef","x","y","movesAfterTouchRef","allowInputSyncRef","unsubscribeFromGlobalContextMenuRef","isTouchingButtonRef","hasTouchedInputRef","ignoreClickRef","pointerTypeRef","initialValue","prev","inputValue","setInputValue","useState","inputMode","setInputMode","isMin","isMax","getAllowedNonNumericKeys","decimal","group","currency","keys","Array","from","Set","push","getStepAmount","current","setValue","unvalidatedValue","event","validatedValue","incrementValue","amount","dir","currentValue","prevValue","nextValue","Math","stopAutoChange","window","clearTimeout","clearInterval","startAutoChange","isIncrement","win","handleContextMenu","preventDefault","addEventListener","removeEventListener","once","tick","setTimeout","setInterval","syncFormattedInputValueOnValueChange","nextInputValue","setDynamicInputModeForIOS","computedInputMode","useEffect","registerGlobalStepModifierKeyListeners","handleWindowKeyDown","shiftKey","altKey","handleWindowKeyUp","handleWindowBlur","registerElementWheelListener","element","handleWheel","ctrlKey","activeElement","deltaY","getGroupProps","useCallback","externalProps","role","getCommonButtonProps","commitValue","nativeEvent","parsedValue","type","tabIndex","WebkitUserSelect","userSelect","onTouchStart","onTouchEnd","onClick","isDisabled","defaultPrevented","detail","onPointerDown","isMainButton","button","pointerType","clientX","clientY","focus","moves","onPointerMove","dx","dy","onMouseEnter","onMouseLeave","onMouseUp","getIncrementButtonProps","getDecrementButtonProps","getInputProps","ref","autoComplete","autoCorrect","spellCheck","suppressHydrationWarning","onFocus","target","currentTarget","length","setSelectionRange","onBlur","trim","onChange","targetValue","isTrusted","onKeyDown","allowedNonNumericKeys","isAllowedNonNumericKey","includes","key","percentSign","selectionStart","selectionEnd","isAllSelected","isMinusHighlighted","forEach","symbol","symbolIndex","indexOf","isSymbolHighlighted","isLatinNumeral","test","isArabicNumeral","isHanNumeral","isNavigateKey","which","metaKey","onPaste","clipboardData","Clipboard","pastedData","getData","scrub","useMemo","UseNumberFieldRoot"],"sources":["/Users/bobbycrew/Documents/Uni/Second Year/Car-Auction-Site-Y2--main/Frontend/node_modules/@base-ui-components/react/esm/number-field/root/useNumberFieldRoot.js"],"sourcesContent":["'use client';\n\nimport * as React from 'react';\nimport { useScrub } from './useScrub.js';\nimport { formatNumber } from '../../utils/formatNumber.js';\nimport { toValidatedNumber } from '../utils/validate.js';\nimport { ARABIC_RE, HAN_RE, PERCENTAGES, getNumberLocaleDetails, parseNumber } from '../utils/parse.js';\nimport { CHANGE_VALUE_TICK_DELAY, DEFAULT_STEP, MAX_POINTER_MOVES_AFTER_TOUCH, SCROLLING_POINTER_MOVE_DISTANCE, START_AUTO_CHANGE_DELAY, TOUCH_TIMEOUT } from '../utils/constants.js';\nimport { isIOS } from '../../utils/detectBrowser.js';\nimport { mergeReactProps } from '../../utils/mergeReactProps.js';\nimport { ownerDocument, ownerWindow } from '../../utils/owner.js';\nimport { useControlled } from '../../utils/useControlled.js';\nimport { useEnhancedEffect } from '../../utils/useEnhancedEffect.js';\nimport { useEventCallback } from '../../utils/useEventCallback.js';\nimport { useForcedRerendering } from '../../utils/useForcedRerendering.js';\nimport { useBaseUiId } from '../../utils/useBaseUiId.js';\nimport { useLatestRef } from '../../utils/useLatestRef.js';\nimport { useFieldRootContext } from '../../field/root/FieldRootContext.js';\nimport { useFieldControlValidation } from '../../field/control/useFieldControlValidation.js';\nimport { useForkRef } from '../../utils/useForkRef.js';\nimport { useField } from '../../field/useField.js';\nexport function useNumberFieldRoot(params) {\n  const {\n    id: idProp,\n    name,\n    min,\n    max,\n    smallStep = 0.1,\n    step,\n    largeStep = 10,\n    required = false,\n    disabled: disabledProp = false,\n    invalid = false,\n    readOnly = false,\n    autoFocus = false,\n    allowWheelScrub = false,\n    format,\n    value: externalValue,\n    onValueChange: onValueChangeProp,\n    defaultValue\n  } = params;\n  const {\n    labelId,\n    setControlId,\n    validationMode,\n    setTouched,\n    setDirty,\n    validityData,\n    setValidityData,\n    disabled: fieldDisabled,\n    setFocused,\n    setFilled\n  } = useFieldRootContext();\n  const {\n    getInputValidationProps,\n    getValidationProps,\n    inputRef: inputValidationRef,\n    commitValidation\n  } = useFieldControlValidation();\n  const disabled = fieldDisabled || disabledProp;\n  const minWithDefault = min ?? Number.MIN_SAFE_INTEGER;\n  const maxWithDefault = max ?? Number.MAX_SAFE_INTEGER;\n  const minWithZeroDefault = min ?? 0;\n  const formatStyle = format?.style;\n  const inputRef = React.useRef(null);\n  const mergedRef = useForkRef(inputRef, inputValidationRef);\n  const id = useBaseUiId(idProp);\n  useEnhancedEffect(() => {\n    setControlId(id);\n    return () => {\n      setControlId(undefined);\n    };\n  }, [id, setControlId]);\n  const [valueUnwrapped, setValueUnwrapped] = useControlled({\n    controlled: externalValue,\n    default: defaultValue,\n    name: 'NumberField',\n    state: 'value'\n  });\n  const value = valueUnwrapped ?? null;\n  const valueRef = useLatestRef(value);\n  useEnhancedEffect(() => {\n    setFilled(value !== null);\n  }, [setFilled, value]);\n  useField({\n    id,\n    commitValidation,\n    value,\n    controlRef: inputRef\n  });\n  const forceRender = useForcedRerendering();\n  const formatOptionsRef = useLatestRef(format);\n  const onValueChange = useEventCallback(onValueChangeProp);\n  const startTickTimeoutRef = React.useRef(-1);\n  const tickIntervalRef = React.useRef(-1);\n  const intentionalTouchCheckTimeoutRef = React.useRef(-1);\n  const isPressedRef = React.useRef(false);\n  const isHoldingShiftRef = React.useRef(false);\n  const isHoldingAltRef = React.useRef(false);\n  const incrementDownCoordsRef = React.useRef({\n    x: 0,\n    y: 0\n  });\n  const movesAfterTouchRef = React.useRef(0);\n  const allowInputSyncRef = React.useRef(true);\n  const unsubscribeFromGlobalContextMenuRef = React.useRef(() => {});\n  const isTouchingButtonRef = React.useRef(false);\n  const hasTouchedInputRef = React.useRef(false);\n  const ignoreClickRef = React.useRef(false);\n  const pointerTypeRef = React.useRef('');\n  useEnhancedEffect(() => {\n    if (validityData.initialValue === null && value !== validityData.initialValue) {\n      setValidityData(prev => ({\n        ...prev,\n        initialValue: value\n      }));\n    }\n  }, [setValidityData, validityData.initialValue, value]);\n\n  // During SSR, the value is formatted on the server, whose locale may differ from the client's\n  // locale. This causes a hydration mismatch, which we manually suppress. This is preferable to\n  // rendering an empty input field and then updating it with the formatted value, as the user\n  // can still see the value prior to hydration, even if it's not formatted correctly.\n  const [inputValue, setInputValue] = React.useState(() => formatNumber(value, [], format));\n  const [inputMode, setInputMode] = React.useState('numeric');\n  const isMin = value != null && value <= minWithDefault;\n  const isMax = value != null && value >= maxWithDefault;\n  const getAllowedNonNumericKeys = useEventCallback(() => {\n    const {\n      decimal,\n      group,\n      currency\n    } = getNumberLocaleDetails([], format);\n    const keys = Array.from(new Set(['.', ',', decimal, group]));\n    if (formatStyle === 'percent') {\n      keys.push(...PERCENTAGES);\n    }\n    if (formatStyle === 'currency' && currency) {\n      keys.push(currency);\n    }\n    if (minWithDefault < 0) {\n      keys.push('-');\n    }\n    return keys;\n  });\n  const getStepAmount = useEventCallback(() => {\n    if (isHoldingAltRef.current) {\n      return smallStep;\n    }\n    if (isHoldingShiftRef.current) {\n      return largeStep;\n    }\n    return step;\n  });\n  const setValue = useEventCallback((unvalidatedValue, event) => {\n    const validatedValue = toValidatedNumber(unvalidatedValue, {\n      step: getStepAmount(),\n      format: formatOptionsRef.current,\n      minWithDefault,\n      maxWithDefault,\n      minWithZeroDefault\n    });\n    onValueChange?.(validatedValue, event);\n    setValueUnwrapped(validatedValue);\n    setDirty(validatedValue !== validityData.initialValue);\n    if (validationMode === 'onChange') {\n      commitValidation(validatedValue);\n    }\n\n    // We need to force a re-render, because while the value may be unchanged, the formatting may\n    // be different. This forces the `useEnhancedEffect` to run which acts as a single source of\n    // truth to sync the input value.\n    forceRender();\n  });\n  const incrementValue = useEventCallback((amount, dir, currentValue, event) => {\n    const prevValue = currentValue == null ? valueRef.current : currentValue;\n    const nextValue = typeof prevValue === 'number' ? prevValue + amount * dir : Math.max(0, min ?? 0);\n    setValue(nextValue, event);\n  });\n  const stopAutoChange = useEventCallback(() => {\n    window.clearTimeout(intentionalTouchCheckTimeoutRef.current);\n    window.clearTimeout(startTickTimeoutRef.current);\n    window.clearInterval(tickIntervalRef.current);\n    unsubscribeFromGlobalContextMenuRef.current();\n    movesAfterTouchRef.current = 0;\n  });\n  const startAutoChange = useEventCallback(isIncrement => {\n    stopAutoChange();\n    if (!inputRef.current) {\n      return;\n    }\n    const win = ownerWindow(inputRef.current);\n    function handleContextMenu(event) {\n      event.preventDefault();\n    }\n\n    // A global context menu is necessary to prevent the context menu from appearing when the touch\n    // is slightly outside of the element's hit area.\n    win.addEventListener('contextmenu', handleContextMenu);\n    unsubscribeFromGlobalContextMenuRef.current = () => {\n      win.removeEventListener('contextmenu', handleContextMenu);\n    };\n    win.addEventListener('pointerup', () => {\n      isPressedRef.current = false;\n      stopAutoChange();\n    }, {\n      once: true\n    });\n    function tick() {\n      const amount = getStepAmount() ?? DEFAULT_STEP;\n      incrementValue(amount, isIncrement ? 1 : -1);\n    }\n    tick();\n    startTickTimeoutRef.current = window.setTimeout(() => {\n      tickIntervalRef.current = window.setInterval(tick, CHANGE_VALUE_TICK_DELAY);\n    }, START_AUTO_CHANGE_DELAY);\n  });\n\n  // We need to update the input value when the external `value` prop changes. This ends up acting\n  // as a single source of truth to update the input value, bypassing the need to manually set it in\n  // each event handler internally in this hook.\n  // This is done inside a layout effect as an alternative to the technique to set state during\n  // render as we're accessing a ref, which must be inside an effect.\n  // https://react.dev/learn/you-might-not-need-an-effect#adjusting-some-state-when-a-prop-changes\n  //\n  // ESLint is disabled because it needs to run even if the parsed value hasn't changed, since the\n  // value still can be formatted differently.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useEnhancedEffect(function syncFormattedInputValueOnValueChange() {\n    // This ensures the value is only updated on blur rather than every keystroke, but still\n    // allows the input value to be updated when the value is changed externally.\n    if (!allowInputSyncRef.current) {\n      return;\n    }\n    const nextInputValue = formatNumber(value, [], formatOptionsRef.current);\n    if (nextInputValue !== inputValue) {\n      setInputValue(nextInputValue);\n    }\n  });\n  useEnhancedEffect(function setDynamicInputModeForIOS() {\n    if (!isIOS()) {\n      return;\n    }\n\n    // iOS numeric software keyboard doesn't have a minus key, so we need to use the default\n    // keyboard to let the user input a negative number.\n    let computedInputMode = 'text';\n    if (minWithDefault >= 0) {\n      // iOS numeric software keyboard doesn't have a decimal key for \"numeric\" input mode, but\n      // this is better than the \"text\" input if possible to use.\n      computedInputMode = 'decimal';\n    }\n    setInputMode(computedInputMode);\n  }, [minWithDefault, formatStyle]);\n  React.useEffect(() => {\n    return () => stopAutoChange();\n  }, [stopAutoChange]);\n  React.useEffect(function registerGlobalStepModifierKeyListeners() {\n    if (disabled || readOnly || !inputRef.current) {\n      return undefined;\n    }\n    function handleWindowKeyDown(event) {\n      if (event.shiftKey) {\n        isHoldingShiftRef.current = true;\n      }\n      if (event.altKey) {\n        isHoldingAltRef.current = true;\n      }\n    }\n    function handleWindowKeyUp(event) {\n      if (!event.shiftKey) {\n        isHoldingShiftRef.current = false;\n      }\n      if (!event.altKey) {\n        isHoldingAltRef.current = false;\n      }\n    }\n    function handleWindowBlur() {\n      // A keyup event may not be dispatched when the window loses focus.\n      isHoldingShiftRef.current = false;\n      isHoldingAltRef.current = false;\n    }\n    const win = ownerWindow(inputRef.current);\n    win.addEventListener('keydown', handleWindowKeyDown, true);\n    win.addEventListener('keyup', handleWindowKeyUp, true);\n    win.addEventListener('blur', handleWindowBlur);\n    return () => {\n      win.removeEventListener('keydown', handleWindowKeyDown, true);\n      win.removeEventListener('keyup', handleWindowKeyUp, true);\n      win.removeEventListener('blur', handleWindowBlur);\n    };\n  }, [disabled, readOnly]);\n\n  // The `onWheel` prop can't be prevented, so we need to use a global event listener.\n  React.useEffect(function registerElementWheelListener() {\n    const element = inputRef.current;\n    if (disabled || readOnly || !allowWheelScrub || !element) {\n      return undefined;\n    }\n    function handleWheel(event) {\n      if (\n      // Allow pinch-zooming.\n      event.ctrlKey || ownerDocument(inputRef.current).activeElement !== inputRef.current) {\n        return;\n      }\n\n      // Prevent the default behavior to avoid scrolling the page.\n      event.preventDefault();\n      const amount = getStepAmount() ?? DEFAULT_STEP;\n      incrementValue(amount, event.deltaY > 0 ? -1 : 1, undefined, event);\n    }\n    element.addEventListener('wheel', handleWheel);\n    return () => {\n      element.removeEventListener('wheel', handleWheel);\n    };\n  }, [allowWheelScrub, incrementValue, disabled, readOnly, largeStep, step, getStepAmount]);\n  const getGroupProps = React.useCallback((externalProps = {}) => mergeReactProps(externalProps, {\n    role: 'group'\n  }), []);\n  const getCommonButtonProps = React.useCallback((isIncrement, externalProps = {}) => {\n    function commitValue(nativeEvent) {\n      allowInputSyncRef.current = true;\n\n      // The input may be dirty but not yet blurred, so the value won't have been committed.\n      const parsedValue = parseNumber(inputValue, formatOptionsRef.current);\n      if (parsedValue !== null) {\n        // The increment value function needs to know the current input value to increment it\n        // correctly.\n        valueRef.current = parsedValue;\n        setValue(parsedValue, nativeEvent);\n      }\n    }\n    return mergeReactProps(externalProps, {\n      disabled: disabled || (isIncrement ? isMax : isMin),\n      type: 'button',\n      'aria-readonly': readOnly || undefined,\n      'aria-label': isIncrement ? 'Increase' : 'Decrease',\n      'aria-controls': id,\n      // Keyboard users shouldn't have access to the buttons, since they can use the input element\n      // to change the value. On the other hand, `aria-hidden` is not applied because touch screen\n      // readers should be able to use the buttons.\n      tabIndex: -1,\n      style: {\n        WebkitUserSelect: 'none',\n        userSelect: 'none'\n      },\n      onTouchStart() {\n        isTouchingButtonRef.current = true;\n      },\n      onTouchEnd() {\n        isTouchingButtonRef.current = false;\n      },\n      onClick(event) {\n        const isDisabled = disabled || readOnly || (isIncrement ? isMax : isMin);\n        if (event.defaultPrevented || isDisabled || (\n        // If it's not a keyboard/virtual click, ignore.\n        pointerTypeRef.current === 'touch' ? ignoreClickRef.current : event.detail !== 0)) {\n          return;\n        }\n        commitValue(event.nativeEvent);\n        const amount = getStepAmount() ?? DEFAULT_STEP;\n        incrementValue(amount, isIncrement ? 1 : -1, undefined, event.nativeEvent);\n      },\n      onPointerDown(event) {\n        const isMainButton = !event.button || event.button === 0;\n        const isDisabled = disabled || (isIncrement ? isMax : isMin);\n        if (event.defaultPrevented || readOnly || !isMainButton || isDisabled) {\n          return;\n        }\n        pointerTypeRef.current = event.pointerType;\n        ignoreClickRef.current = false;\n        isPressedRef.current = true;\n        incrementDownCoordsRef.current = {\n          x: event.clientX,\n          y: event.clientY\n        };\n        commitValue(event.nativeEvent);\n\n        // Note: \"pen\" is sometimes returned for mouse usage on Linux Chrome.\n        if (event.pointerType !== 'touch') {\n          event.preventDefault();\n          inputRef.current?.focus();\n          startAutoChange(isIncrement);\n        } else {\n          // We need to check if the pointerdown was intentional, and not the result of a scroll\n          // or pinch-zoom. In that case, we don't want to change the value.\n          intentionalTouchCheckTimeoutRef.current = window.setTimeout(() => {\n            const moves = movesAfterTouchRef.current;\n            movesAfterTouchRef.current = 0;\n            if (moves < MAX_POINTER_MOVES_AFTER_TOUCH) {\n              ignoreClickRef.current = true;\n              startAutoChange(isIncrement);\n            } else {\n              stopAutoChange();\n            }\n          }, TOUCH_TIMEOUT);\n        }\n      },\n      onPointerMove(event) {\n        const isDisabled = disabled || readOnly || (isIncrement ? isMax : isMin);\n        if (isDisabled || event.pointerType !== 'touch' || !isPressedRef.current) {\n          return;\n        }\n        movesAfterTouchRef.current += 1;\n        const {\n          x,\n          y\n        } = incrementDownCoordsRef.current;\n        const dx = x - event.clientX;\n        const dy = y - event.clientY;\n\n        // An alternative to this technique is to detect when the NumberField's parent container\n        // has been scrolled\n        if (dx ** 2 + dy ** 2 > SCROLLING_POINTER_MOVE_DISTANCE ** 2) {\n          stopAutoChange();\n        }\n      },\n      onMouseEnter(event) {\n        const isDisabled = disabled || readOnly || (isIncrement ? isMax : isMin);\n        if (event.defaultPrevented || isDisabled || !isPressedRef.current || isTouchingButtonRef.current) {\n          return;\n        }\n        startAutoChange(isIncrement);\n      },\n      onMouseLeave() {\n        if (isTouchingButtonRef.current) {\n          return;\n        }\n        stopAutoChange();\n      },\n      onMouseUp() {\n        if (isTouchingButtonRef.current) {\n          return;\n        }\n        stopAutoChange();\n      }\n    });\n  }, [disabled, isMax, isMin, readOnly, id, getStepAmount, incrementValue, inputValue, formatOptionsRef, valueRef, setValue, startAutoChange, stopAutoChange]);\n  const getIncrementButtonProps = React.useCallback(externalProps => getCommonButtonProps(true, externalProps), [getCommonButtonProps]);\n  const getDecrementButtonProps = React.useCallback(externalProps => getCommonButtonProps(false, externalProps), [getCommonButtonProps]);\n  const getInputProps = React.useCallback((externalProps = {}) => mergeReactProps(getInputValidationProps(getValidationProps(externalProps)), {\n    id,\n    required,\n    autoFocus,\n    name,\n    disabled,\n    readOnly,\n    inputMode,\n    value: inputValue,\n    ref: mergedRef,\n    type: 'text',\n    autoComplete: 'off',\n    autoCorrect: 'off',\n    spellCheck: 'false',\n    'aria-roledescription': 'Number field',\n    'aria-invalid': invalid || undefined,\n    'aria-labelledby': labelId,\n    // If the server's locale does not match the client's locale, the formatting may not match,\n    // causing a hydration mismatch.\n    suppressHydrationWarning: true,\n    onFocus(event) {\n      if (event.defaultPrevented || readOnly || disabled || hasTouchedInputRef.current) {\n        return;\n      }\n      hasTouchedInputRef.current = true;\n      setFocused(true);\n\n      // Browsers set selection at the start of the input field by default. We want to set it at\n      // the end for the first focus.\n      const target = event.currentTarget;\n      const length = target.value.length;\n      target.setSelectionRange(length, length);\n    },\n    onBlur(event) {\n      if (event.defaultPrevented || readOnly || disabled) {\n        return;\n      }\n      setTouched(true);\n      setFocused(false);\n      if (validationMode === 'onBlur') {\n        commitValidation(valueRef.current);\n      }\n      allowInputSyncRef.current = true;\n      if (inputValue.trim() === '') {\n        setValue(null);\n        return;\n      }\n      const parsedValue = parseNumber(inputValue, formatOptionsRef.current);\n      if (parsedValue !== null) {\n        setValue(parsedValue, event.nativeEvent);\n      }\n    },\n    onChange(event) {\n      // Workaround for https://github.com/facebook/react/issues/9023\n      if (event.nativeEvent.defaultPrevented) {\n        return;\n      }\n      allowInputSyncRef.current = false;\n      const targetValue = event.target.value;\n      if (targetValue.trim() === '') {\n        setInputValue(targetValue);\n        setValue(null, event.nativeEvent);\n        return;\n      }\n      if (event.isTrusted) {\n        setInputValue(targetValue);\n        return;\n      }\n      const parsedValue = parseNumber(targetValue, formatOptionsRef.current);\n      if (parsedValue !== null) {\n        setInputValue(targetValue);\n        setValue(parsedValue, event.nativeEvent);\n      }\n    },\n    onKeyDown(event) {\n      if (event.defaultPrevented || readOnly || disabled) {\n        return;\n      }\n      const nativeEvent = event.nativeEvent;\n      allowInputSyncRef.current = true;\n      const allowedNonNumericKeys = getAllowedNonNumericKeys();\n      let isAllowedNonNumericKey = allowedNonNumericKeys.includes(event.key);\n      const {\n        decimal,\n        currency,\n        percentSign\n      } = getNumberLocaleDetails([], formatOptionsRef.current);\n      const selectionStart = event.currentTarget.selectionStart;\n      const selectionEnd = event.currentTarget.selectionEnd;\n      const isAllSelected = selectionStart === 0 && selectionEnd === inputValue.length;\n\n      // Allow the minus key only if there isn't already a plus or minus sign, or if all the text\n      // is selected, or if only the minus sign is highlighted.\n      if (event.key === '-' && allowedNonNumericKeys.includes('-')) {\n        const isMinusHighlighted = selectionStart === 0 && selectionEnd === 1 && inputValue[0] === '-';\n        isAllowedNonNumericKey = !inputValue.includes('-') || isAllSelected || isMinusHighlighted;\n      }\n\n      // Only allow one of each symbol.\n      [decimal, currency, percentSign].forEach(symbol => {\n        if (event.key === symbol) {\n          const symbolIndex = inputValue.indexOf(symbol);\n          const isSymbolHighlighted = selectionStart === symbolIndex && selectionEnd === symbolIndex + 1;\n          isAllowedNonNumericKey = !inputValue.includes(symbol) || isAllSelected || isSymbolHighlighted;\n        }\n      });\n      const isLatinNumeral = /^[0-9]$/.test(event.key);\n      const isArabicNumeral = ARABIC_RE.test(event.key);\n      const isHanNumeral = HAN_RE.test(event.key);\n      const isNavigateKey = ['Backspace', 'Delete', 'ArrowLeft', 'ArrowRight', 'Tab', 'Enter'].includes(event.key);\n      if (\n      // Allow composition events (e.g., pinyin)\n      // event.nativeEvent.isComposing does not work in Safari:\n      // https://bugs.webkit.org/show_bug.cgi?id=165004\n      event.which === 229 || event.altKey || event.ctrlKey || event.metaKey || isAllowedNonNumericKey || isLatinNumeral || isArabicNumeral || isHanNumeral || isNavigateKey) {\n        return;\n      }\n\n      // We need to commit the number at this point if the input hasn't been blurred.\n      const parsedValue = parseNumber(inputValue, formatOptionsRef.current);\n      const amount = getStepAmount() ?? DEFAULT_STEP;\n\n      // Prevent insertion of text or caret from moving.\n      event.preventDefault();\n      if (event.key === 'ArrowUp') {\n        incrementValue(amount, 1, parsedValue, nativeEvent);\n      } else if (event.key === 'ArrowDown') {\n        incrementValue(amount, -1, parsedValue, nativeEvent);\n      } else if (event.key === 'Home' && min != null) {\n        setValue(min, nativeEvent);\n      } else if (event.key === 'End' && max != null) {\n        setValue(max, nativeEvent);\n      }\n    },\n    onPaste(event) {\n      if (event.defaultPrevented || readOnly || disabled) {\n        return;\n      }\n\n      // Prevent `onChange` from being called.\n      event.preventDefault();\n      const clipboardData = event.clipboardData || window.Clipboard;\n      const pastedData = clipboardData.getData('text/plain');\n      const parsedValue = parseNumber(pastedData, formatOptionsRef.current);\n      if (parsedValue !== null) {\n        allowInputSyncRef.current = false;\n        setValue(parsedValue, event.nativeEvent);\n        setInputValue(pastedData);\n      }\n    }\n  }), [getInputValidationProps, getValidationProps, id, required, autoFocus, name, disabled, readOnly, inputMode, inputValue, mergedRef, invalid, labelId, setFocused, setTouched, validationMode, formatOptionsRef, commitValidation, valueRef, setValue, getAllowedNonNumericKeys, getStepAmount, min, max, incrementValue]);\n  const scrub = useScrub({\n    disabled,\n    readOnly,\n    value,\n    inputRef,\n    incrementValue,\n    getStepAmount\n  });\n  return React.useMemo(() => ({\n    getGroupProps,\n    getInputProps,\n    getIncrementButtonProps,\n    getDecrementButtonProps,\n    inputRef: mergedRef,\n    inputValue,\n    value,\n    ...scrub\n  }), [getGroupProps, getInputProps, getIncrementButtonProps, getDecrementButtonProps, mergedRef, inputValue, value, scrub]);\n}\nexport let UseNumberFieldRoot;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}