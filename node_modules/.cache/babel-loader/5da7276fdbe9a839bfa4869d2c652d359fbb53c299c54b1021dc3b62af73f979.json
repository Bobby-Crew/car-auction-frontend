{"ast":null,"code":"/**\n * Merges multiple sets of React props such that their event handlers are called in sequence (the user's\n * before our internal ones), and allows the user to prevent the internal event handlers from being\n * executed by attaching a `preventBaseUIHandler` method. It also merges the `style` prop, whereby\n * the user's styles overwrite the internal ones.\n * @important **`className` and `ref` are not merged.**\n * @param externalProps the user's external props.\n * @param internalProps our own internal props.\n * @returns the merged props.\n */\nexport function mergeReactProps(externalProps, ...internalProps) {\n  let mergedInternalProps = internalProps[0];\n  for (let i = 1; i < internalProps.length; i += 1) {\n    mergedInternalProps = merge(mergedInternalProps, internalProps[i]);\n  }\n  return merge(externalProps, mergedInternalProps);\n}\nfunction merge(externalProps, internalProps) {\n  if (!externalProps) {\n    return internalProps;\n  }\n  return Object.entries(externalProps).reduce((acc, [key, value]) => {\n    if (\n    // This approach is more efficient than using a regex.\n    key[0] === 'o' && key[1] === 'n' && key.charCodeAt(2) >= 65 /* A */ && key.charCodeAt(2) <= 90 /* Z */ && typeof value === 'function') {\n      acc[key] = event => {\n        let isPrevented = false;\n        const theirHandler = value;\n        const ourHandler = internalProps[key];\n        const baseUIEvent = event;\n        baseUIEvent.preventBaseUIHandler = () => {\n          isPrevented = true;\n        };\n        const result = theirHandler(baseUIEvent);\n        if (!isPrevented) {\n          ourHandler?.(baseUIEvent);\n        }\n        return result;\n      };\n    } else if (key === 'style') {\n      if (value || internalProps.style) {\n        acc[key] = {\n          ...internalProps.style,\n          ...(value || {})\n        };\n      }\n    } else if (key === 'className') {\n      if (value) {\n        if (internalProps.className) {\n          // eslint-disable-next-line prefer-template\n          acc[key] = value + ' ' + internalProps.className;\n        } else {\n          acc[key] = value;\n        }\n      } else {\n        acc[key] = internalProps.className;\n      }\n    } else {\n      acc[key] = value;\n    }\n    return acc;\n  }, {\n    ...internalProps\n  });\n}","map":{"version":3,"names":["mergeReactProps","externalProps","internalProps","mergedInternalProps","i","length","merge","Object","entries","reduce","acc","key","value","charCodeAt","event","isPrevented","theirHandler","ourHandler","baseUIEvent","preventBaseUIHandler","result","style","className"],"sources":["/Users/bobbycrew/Documents/Uni/Second Year/Car-Auction-Site-Y2--main/Frontend/node_modules/@base-ui-components/react/esm/utils/mergeReactProps.js"],"sourcesContent":["/**\n * Merges multiple sets of React props such that their event handlers are called in sequence (the user's\n * before our internal ones), and allows the user to prevent the internal event handlers from being\n * executed by attaching a `preventBaseUIHandler` method. It also merges the `style` prop, whereby\n * the user's styles overwrite the internal ones.\n * @important **`className` and `ref` are not merged.**\n * @param externalProps the user's external props.\n * @param internalProps our own internal props.\n * @returns the merged props.\n */\nexport function mergeReactProps(externalProps, ...internalProps) {\n  let mergedInternalProps = internalProps[0];\n  for (let i = 1; i < internalProps.length; i += 1) {\n    mergedInternalProps = merge(mergedInternalProps, internalProps[i]);\n  }\n  return merge(externalProps, mergedInternalProps);\n}\nfunction merge(externalProps, internalProps) {\n  if (!externalProps) {\n    return internalProps;\n  }\n  return Object.entries(externalProps).reduce((acc, [key, value]) => {\n    if (\n    // This approach is more efficient than using a regex.\n    key[0] === 'o' && key[1] === 'n' && key.charCodeAt(2) >= 65 /* A */ && key.charCodeAt(2) <= 90 /* Z */ && typeof value === 'function') {\n      acc[key] = event => {\n        let isPrevented = false;\n        const theirHandler = value;\n        const ourHandler = internalProps[key];\n        const baseUIEvent = event;\n        baseUIEvent.preventBaseUIHandler = () => {\n          isPrevented = true;\n        };\n        const result = theirHandler(baseUIEvent);\n        if (!isPrevented) {\n          ourHandler?.(baseUIEvent);\n        }\n        return result;\n      };\n    } else if (key === 'style') {\n      if (value || internalProps.style) {\n        acc[key] = {\n          ...internalProps.style,\n          ...(value || {})\n        };\n      }\n    } else if (key === 'className') {\n      if (value) {\n        if (internalProps.className) {\n          // eslint-disable-next-line prefer-template\n          acc[key] = value + ' ' + internalProps.className;\n        } else {\n          acc[key] = value;\n        }\n      } else {\n        acc[key] = internalProps.className;\n      }\n    } else {\n      acc[key] = value;\n    }\n    return acc;\n  }, {\n    ...internalProps\n  });\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,eAAeA,CAACC,aAAa,EAAE,GAAGC,aAAa,EAAE;EAC/D,IAAIC,mBAAmB,GAAGD,aAAa,CAAC,CAAC,CAAC;EAC1C,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,aAAa,CAACG,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;IAChDD,mBAAmB,GAAGG,KAAK,CAACH,mBAAmB,EAAED,aAAa,CAACE,CAAC,CAAC,CAAC;EACpE;EACA,OAAOE,KAAK,CAACL,aAAa,EAAEE,mBAAmB,CAAC;AAClD;AACA,SAASG,KAAKA,CAACL,aAAa,EAAEC,aAAa,EAAE;EAC3C,IAAI,CAACD,aAAa,EAAE;IAClB,OAAOC,aAAa;EACtB;EACA,OAAOK,MAAM,CAACC,OAAO,CAACP,aAAa,CAAC,CAACQ,MAAM,CAAC,CAACC,GAAG,EAAE,CAACC,GAAG,EAAEC,KAAK,CAAC,KAAK;IACjE;IACA;IACAD,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,IAAIA,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,IAAIA,GAAG,CAACE,UAAU,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,WAAWF,GAAG,CAACE,UAAU,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,WAAW,OAAOD,KAAK,KAAK,UAAU,EAAE;MACrIF,GAAG,CAACC,GAAG,CAAC,GAAGG,KAAK,IAAI;QAClB,IAAIC,WAAW,GAAG,KAAK;QACvB,MAAMC,YAAY,GAAGJ,KAAK;QAC1B,MAAMK,UAAU,GAAGf,aAAa,CAACS,GAAG,CAAC;QACrC,MAAMO,WAAW,GAAGJ,KAAK;QACzBI,WAAW,CAACC,oBAAoB,GAAG,MAAM;UACvCJ,WAAW,GAAG,IAAI;QACpB,CAAC;QACD,MAAMK,MAAM,GAAGJ,YAAY,CAACE,WAAW,CAAC;QACxC,IAAI,CAACH,WAAW,EAAE;UAChBE,UAAU,GAAGC,WAAW,CAAC;QAC3B;QACA,OAAOE,MAAM;MACf,CAAC;IACH,CAAC,MAAM,IAAIT,GAAG,KAAK,OAAO,EAAE;MAC1B,IAAIC,KAAK,IAAIV,aAAa,CAACmB,KAAK,EAAE;QAChCX,GAAG,CAACC,GAAG,CAAC,GAAG;UACT,GAAGT,aAAa,CAACmB,KAAK;UACtB,IAAIT,KAAK,IAAI,CAAC,CAAC;QACjB,CAAC;MACH;IACF,CAAC,MAAM,IAAID,GAAG,KAAK,WAAW,EAAE;MAC9B,IAAIC,KAAK,EAAE;QACT,IAAIV,aAAa,CAACoB,SAAS,EAAE;UAC3B;UACAZ,GAAG,CAACC,GAAG,CAAC,GAAGC,KAAK,GAAG,GAAG,GAAGV,aAAa,CAACoB,SAAS;QAClD,CAAC,MAAM;UACLZ,GAAG,CAACC,GAAG,CAAC,GAAGC,KAAK;QAClB;MACF,CAAC,MAAM;QACLF,GAAG,CAACC,GAAG,CAAC,GAAGT,aAAa,CAACoB,SAAS;MACpC;IACF,CAAC,MAAM;MACLZ,GAAG,CAACC,GAAG,CAAC,GAAGC,KAAK;IAClB;IACA,OAAOF,GAAG;EACZ,CAAC,EAAE;IACD,GAAGR;EACL,CAAC,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}